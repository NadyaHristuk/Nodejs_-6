# Lesson 3. Express - фреймворк для веб приложений

- Начало работы с Express.
- Сервер. Маршрутизация, статические файлы
- Обработка форм, POST, GET запросы
- JSON, АJAX
- Конвеер обработки и middleware

## Начало работы с Express

Express представляет собой популярный веб-фреймворк, написанный на JavaScript и работающий внутри среды исполнения node.js.

Он позволяет вам очень просто создать такие возможности в вашем проекте как:

- маршрутизация (роутинг)
- промежуточные обработчики (middleware)
- шаблонизация
- обработка ошибок
- дебаг (отладка)
- интеграция с базами данных

### Middleware (промежуточный обработчик)

Это функция которая имеет доступ к запросу (request) и ответу (response).
Функция может делать любые действия и передавать их результат в response или в следующий middleware.

В экспрессе в middleware есть так же 3й аргумент `next`. Он позволяет перейти сразу к следующемо обработчику события.

Пример:

```
var myLogger = function (req, res, next) {
  console.log('LOGGED');
  next();
};
```

**Для чего можно использовать Middleware:**

- логирование
- отлов ошибок
- преобразование данных с request
- проверка залогинен ли пользователь (аутентификация)

Вот так выглядит использование middleware в коде

```js
var express = require("express");
var app = express();

// создание middleware
var requestTime = function(req, res, next) {
  // Пример: добавляем время к запросу
  req.requestTime = Date.now();
  next();
};

// добавление middleware ко всем роутам
app.use(requestTime);

app.get("/", function(req, res) {
  var responseText = "Hello World!";
  responseText += "Requested at: " + req.requestTime + "";
  res.send(responseText);
});

app.get(
  "/subscribers/:id",
  // добавление middleware к определенному роуту
  function checkIfPaidSubscriber(req, res, next) {
    if (!req.user.hasPaid) {
      // continue handling this request
      next("route");
    }
  },
  function getPaidContent(req, res) {
    PaidContent.find(function(err, doc) {
      if (err) return next(err);
      res.json(doc);
    });
  }
);

app.listen(3000);
```

### Шаблонизация

С помощью Express можно сделать статический сайт, который будет перезагружатся после открытия каждой страницы. Либо же после каждого измненения (если на сайте будет что-то меняться). Как например этот сайт на php https://metanit.com/

Для того чтобы отображать в Express файлы шаблонов, необходимо задать следующие параметры приложения:

**views** - каталог, в котором находятся файлы шаблонов. Например: app.set('views', './views')

**view engine** - используемый шаблонизатор. Например: app.set('view engine', 'pug')

Cначала нам нужно установить шаблонизатор. Например `pug` https://pugjs.org/api/getting-started.html

Следующим шагом создаем шаблон `index.pug`

```
html
  head
    title= title
  body
    h1= message
```

`title` и `message` это переменные вместо которых можно что-то подставить

Затем создаем роут для вывода файла index.pug. Если свойство view engine не задано, необходимо указать расширение файла view. В противном случае, можно не указывать расширение.

```
app.get('/', function (req, res) {
  res.render('index', { title: 'Hey', message: 'Hello there!'});
});
```

При выполнении запроса к домашней странице файл index.pug будет отображаться как HTML.

Статьи:

- http://expressjs.com/ru/guide/using-template-engines.html
- создание своего шаблонизатора http://expressjs.com/ru/advanced/developing-template-engines.html

### Обработка ошибок

Если в JS возникает ошибка что никак не обрабатывается то JS перестает выполнятся дальше. По этому особенно важно отлавливать ошибки в вашем бекенд приложении. Иначе он просто упадет.

Такие функции реализуются с помощью `middleware`, но с указанием для функции обработки ошибок не трех, а четырех аргументов: (err, req, res, next).

Пример:

```
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

Обработчик для обработки ошибок должен быть определен последним, после указания всех app.use() и вызовов роутов;

Пример:

```
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
```

Так же в Express предусмотрен встроенный обработчик ошибок, который обрабатывает любые возможные ошибки, встречающиеся в приложении. Этот стандартный обработчик ошибок добавляется в конец всех функций промежуточной обработки(middleware).

### Отладка (debug)

В Express используется внутренний модуль debug для регистрации информации о сопоставлениях маршрутов, используемых функциях промежуточной обработки, режиме приложения и выполнении цикла “запрос-ответ”.

При запуске команды вам в консоли выведутся все операции что были сделаны за определенные время.

Например

```
const debug = require('debug')('http')
const http = require('http')
const name = 'My App';

debug('booting %o', name);

http.createServer(function(req, res){
  debug(req.method + ' ' + req.url);
  res.end('hello\n');
}).listen(3000, function(){
  debug('listening');
});

```

В консоли вы увидите

<img src="./img/1.png" />

Список всех операций и сколько времени заняла каждая их них.

Более детально:

- https://expressjs.com/ru/guide/debugging.html
- https://www.npmjs.com/package/debug

## Руководство по кросс-доменным запросам (CORS)

Обычно запрос XMLHttpRequest может делать запрос только в рамках текущего сайта. При попытке использовать другой домен/порт/протокол – браузер выдаёт ошибку.

Существует современный стандарт XMLHttpRequest, он ещё в состоянии черновика, но предусматривает кросс-доменные запросы и многое другое.

Большинство возможностей этого стандарта уже поддерживаются всеми браузерами, но увы, не в IE9-.

Впрочем, частично кросс-доменные запросы поддерживаются, начиная с IE8, только вместо XMLHttpRequest нужно использовать объект XDomainRequest.

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Пример cross-origin запроса: HTML страница, обслуживаемая сервером с http://domain-a.com, запрашивает <img> src по адресу http://domain-b.com/image.jpg. Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.

![](CORS_principle.png)

Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищенному соединению. Современные браузеры используют CORS в API-контейнерах, таких как XMLHttpRequest или Fetch, чтобы снизить риски, присущие запросам с других источников.

Для работы с кросс-доменными запросами используем библиотеку - Cors

сначала установите Cors в своем приложении.

```javascript
npm i cors
```

после установки cors необходимо подключение модуля к вашему основному файлу

```javascript
const cors = require("cors");
```

И теперь надо передать функции из приложения cors к нашему экземпляру Express с помощью директивы .use
Простой вариант использования модуля для всех маршрутов (Enable All CORS Requests)

```javascript
constexpress = require("express");
const cors = require("cors");
const app = express();

app.use(cors());

app.get("/products/:id", function(req, res, next) {
  res.json({ msg: "This is CORS-enabled for all origins!" });
});

app.listen(80, function() {
  console.log("CORS-enabled web server listening on port 80");
});
```

или вот такой вариант, с расширенными настройками

```javascript
let allowCrossDomain = function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*"); // allow requests from any other server
  res.header("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE"); // allow these verbs
  res.header(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept, Cache-Control"
  );
};
app.use(allowCrossDomain); // plumbing it in as middleware
```

## Зачем нужны lock файлы в npm

Это файл, который генерируется автоматически и хранит в себе полное дерево всех зависимостей с версиями. И после его генерации все пакеты устанавливаются по новой с версиями и зависимостями, которые там указаны.

По умолчанию в npm, при установке пакетов у вас автоматически создается и обновляется файл package-lock.json. Вам не нужно ничего дополнительно делать. Вы просто должны закоммитить этот файл также, как и обычный файл проекта в репозиторий.

Если же вы используете yarn, вместо npm, то у вас также автоматически генерируется файл yarn.lock, который лочит все версии.

## О логгировании в Node.js

https://habr.com/ru/post/209436/ - о целях логирования

Morgan был создан для ведения журнала таким образом, что серверы, на Apache и Nginx, регистрируются в error_log или access_log.
Morgan, предназначен для автоматического ведения запросов, ответов и связанных с ними данных.

```
const morgan = require('morgan');
//This tells express to log via morgan
//and morgan to log in the "dev" pre-defined format
app.use(morgan('dev'));
```

Morgan: еще одно промежуточное ПО для регистрации HTTP-запросов для Node.js. Упрощает процесс регистрации запросов к вашему приложению. Вы можете думать о Моргане как о помощнике, который собирает журналы с вашего сервера - журналы ваших запросов. Экономит время разработчиков, поскольку им не нужно вручную создавать общие журналы. Он стандартизирует и автоматически создает журналы запросов.

```
var express = require('express')
var morgan = require('morgan')

var app = express()

//use morgan middleware
app.use(morgan('combined'))

app.get('/', function (req, res) {
  res.send('hello, world!')
})


//server is listening
app.listen(3000, function () {
	console.log("Server started...");
	console.log("Morgan logger with express...");
})

```

После запуска сервера в консоли можно увидеть следующее сообщение
[![](http://www.goodbehind.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-04-18-05-02.png)](http://http://www.goodbehind.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-04-18-05-02.png)

# Как создать базу данных

## Инструкция - Quick-Start Guide to mLab - https://docs.mlab.com/

# Создание кластера базы данных в облаке с помощью MongoDB Atlas

В течение многих лет MongoDB стала де факто NoSQL базой данных для частных лиц и предприятий, создающих крупномасштабные приложения. Она с открытым исходным кодом, легко масштабируется и обеспечивает высокую доступность. Она также поддерживает очень сложные запросы и тщательный контроль параллелизма.

Однако необходимые задачи, такие как установка базы данных, настройка для поддержания оптимальной производительности в течение длительных периодов времени, как правило, требуют много квалифицированных и целеустремленных усилий.

К счастью, есть более простая альтернатива: MongoDB Atlas — полностью управляемая облачная версия базы данных.

С MongoDB Atlas вы можете создать кластер MongoDB для любого основного поставщика облачных вычислений по вашему выбору и начать использовать этот кластер за считанные минуты. Используя пользовательский интерфейс на основе браузера Atlas, вы также можете интуитивно настроить кластер и контролировать его производительность.

## 1. Создание кластера

Чтобы иметь возможность использовать облачные сервисы MongoDB, вам понадобится учетная запись MongoDB Atlas. Чтобы создать ее, перейдите на [домашнюю страницу](https://www.mongodb.com/cloud/atlas?jmp=tuts&Americas_USA_tuts_stitch_tutorials_ATLAS "домашнюю страницу") и нажмите кнопку Get started free.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.09.18.jpg)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.09.18.jpg)

После того, как вы заполните короткую регистрационную форму, вы будете перенаправлены на мастер создания кластера. В первом разделе вам нужно будет выбрать облачный провайдер и регион, который вы предпочитаете.

Чтобы свести к минимуму задержку сети, выберете регион, ближайший к вашему компьютеру. Пока же, поскольку мы создаем кластер пользования бесплатного уровня, убедитесь, что выбранный вами регион является тем, у которого есть свободный уровень. Кроме того, если вы используете виртуальную виртуальную машину Google или инстанс Amazon EC2 в качестве среды разработки, сначала выберите соответствующий облачный провайдер.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.15.05.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.15.05.png)

В разделе Cluster Tier выберите параметр M0, чтобы создать кластер бесплатного уровня. Он предлагает 512 МБ пространства для хранения, последнюю версию MongoDB с WiredTiger в качестве механизма хранения, набор реплик из трех узлов и щедрую пропускную способность 10 ГБ в неделю.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.15.53.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.15.53.png)

Наконец, дайте значимое имя кластеру и нажмите кнопку Create Cluster.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.19.06.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.19.06.png)

Теперь, MongoDB Atlas займет около пяти минут, чтобы настроить ваш кластер.

## 2. Настройка кластера

Прежде чем вы начнете использовать кластер, вам нужно будет предоставить несколько сведений, связанных с безопасностью, поэтому перейдите на вкладку Security.

Во-первых, в разделе MongoDB Users вы должны создать нового пользователя, нажав кнопку Add new user. В появившемся диалоговом окне введите нужное имя пользователя и пароль, выберите Read and write to any database и нажмите кнопку Add User.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.28.16.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.28.16.png)

Затем в разделе IP Whitelist вы должны указать список IP-адресов, с которых вы будете обращаться к кластеру. На данный момент достаточно указать текущий IP-адрес вашего компьютера.

Нажмите кнопку Add IP address, чтобы создать новую запись IP-адреса. В появившемся диалоговом окне нажмите кнопку Add current IP , чтобы заполнить поле Whitelist Entry. Кроме того, если у вас нет статического IP-адреса, рекомендуется отметить его временную запись, указав параметр Save as temporary whitelist. Наконец, нажмите Confirm, чтобы добавить запись.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.31.27.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.31.27.png)

## 3. Получение строки подключения

Для подключения к кластеру из приложения вам понадобится действительная строка подключения. Чтобы получить его, перейдите на вкладку Overview и нажмите кнопку Connect.

В открывшемся диалоговом окне выберите параметр Connect Your Application и нажмите кнопку I'm using driver 3.6 or later. Теперь вы можете увидеть строку подключения. У него не будет вашего фактического пароля, поэтому вам придется его вводить вручную. После этого сделайте заметку о строке, чтобы позже ее использовать.

[![](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.44.08.png)](https://cms-assets.tutsplus.com/uploads/users/362/posts/31840/image/Screen%20Shot%202018-09-09%20at%2008.44.08.png)

И вот видео в котором объясняеться как подключиться к MongoDB Atlas - https://www.youtube.com/watch?v=KKyag6t98g8 - - в видео нужное обьяснение до 7 минуты - именно настройка кластера и получение ссылки, остальное уже не нужно


## “Работа с нереляционными БД” (на примере MongoDB)

### Для добавления в коллекцию могут использоваться три ее метода:
- ```insertOne()```: добавляет один документ
- ```insertMany()```: добавляет несколько документов
- ```insert()```: может добавлять как один, так и несколько документов
```js
db.cats.insertOne({name: 'barsik', age: 3, characteristics: ['гадит в тапки', 'дает себя гладить', 'рябой']})
```
Некоторые ограничения при использовании имен ключей:
1. Символ ```$``` не может быть первым символом в имени ключа
2. Имя ключа не может содержать символ точки .
3. Имя ```_id``` не рекомендуется использовать
```js
db.cats.insertMany([{name: 'Lama', age: 2, characteristics: ['гадит в лоток', 'не дает себя гладить', 'серый']}, {name: 'Liza', age: 4, characteristics: ['гадит в лоток', 'дает себя гладить', 'белый']}])

db.cats.insert([{name: 'Boris', age: 12, characteristics: ['гадит в лоток', 'не дает себя гладить', 'серый']}, {name: 'Murzik', age: 1, characteristics: ['гадит в лоток', 'дает себя гладить', 'черный']}])
```
### Для вывода документов в более удобном наглядном представлении мы можем добавить вызов метода ```pretty()```:
```js

db.cats.find().pretty()

db.cats.find({age: {$lte: 3}, characteristics: 'дает себя гладить'}).pretty()
```
### Проекция:
```js
db.cats.find({age: {$lte: 3}, characteristics: 'дает себя гладить'}, {name: 0}).pretty()

db.cats.find({age: {$lte: 3}, characteristics: 'дает себя гладить'}, {name: 1, age: 1}).pretty()
```
### Запрос к вложенным объектам
```js
db.cats.insert({name: 'Dariy', age: 10, characteristics: ['гадит в лоток', 'не дает себя гладить', 'серый'], owners: {name: 'Nata', age: 23, adress: 'Poltava'}})

db.cats.find({'owners.name': 'Nata'})
```
### Настройка запросов и сортировка:
```js
db.cats.find().limit(3) - первые три
db.cats.find().skip(3) - пропустить первые три
db.cats.find().sort({name: 1}) 

db.cats.findOne({age: {$lte: 3}})
```
### Курсоры
Результат выборки, получаемой с помощью функции ```find```, называется курсором
Курсоры инкапсулируют в себе наборы получаемых из бд объектов. Используя синтаксис языка javascript и методы курсоров, мы можем вывести полученные документы на экран и как-то их обработать. 
```js

var cursor = db.cats.find();
while(cursor.hasNext()){
	obj = cursor.next();
	print(obj["name"]);
}
```
### С помощью функции count() можно получить число элементов в коллекции:
```js
db.cats.count()
db.cats.find({age: {$lte: 3}}).count()
```

### В MongoDB в запросах можно использовать условные конструкции с помощью операторов сравнения:

- ```$eq``` - (равно)
- ```$gt``` - (больше чем)
- ```$lt``` - (меньше чем)
- ```$gte``` - (больше или равно)
- ```$lte``` - (меньше или равно)
```js

db.cats.find ({age: {$lte: 10, $gte:2}})
```
### Поиск по массивам и операторы ```$in, $nin, $all```
Оператор ```$in``` определяет массив возможных выражений и ищет те ключи, значение которых имеется в массиве:
```js
db.cats.find({age: {$in : [2, 10]}})
```
Противоположным образом действует оператор ```$nin``` - он определяет массив возможных выражений и ищет те ключи, значение которых отсутствует в этом массиве
```js
db.cats.find({age: {$nin : [2, 10]}})
```
Оператор ```$all``` похож на ```$in```: он также определяет массив возможных выражений, но требует, чтобы документы имели весь определяемый набор выражений. 
```js
db.cats.find ({"characteristics": {$all : ["гадит в лоток", "дает себя гладить"]}})
```

#### Оператор ```$size```
Оператор ```$size``` используется для нахождения документов, в которых массивы имеют число элементов, равным значению ```$size```. 
```js
db.cats.find({"characteristics": {$size:3}})
```
#### Оператор ```$exists```
Оператор ```$exists``` позволяет извлечь только те документы, в которых определенный ключ присутствует или отсутствует. 
```js
db.cats.find({owners: {$exists:true}})
```
#### Оператор ```$type```
Оператор ```$type``` извлекает только те документы, в которых определенный ключ имеет значение определенного типа, например, строку или число
```js
db.cats.find({age: {$type:"number"}})
```

#### Оператор ```$regex```
Оператор ```$regex``` задает регулярное выражение, которому должно соответствовать значение поля.
```js 
db.cats.find({name: {$regex:"L"}})
```

#### Оператор ```$or```
```js
db.cats.find({$or: [{name: {$regex:"L"}}, {age: {$lte: 3}}]})
```
#### Оператор ```$and```
```js
db.cats.find({$and: [{name: {$regex:"L"}}, {age: {$lte: 3}}]})
```

### Метод save
В этот документ в качестве поля можно передать параметр ```_id```. Если метод находит документ с таким значением ```_id```, то документ обновляется. Если же с подобным ```_id``` нет документов, то документ вставляется.
```js
db.cats.save({"_id": ObjectId("5a571b186a51cf10a4383303"), name: "Bars", age: 3})
```
### Метод update
Более детальную настройку при обновлении предлагает функция update. Она принимает три параметра:

1. ```query```: принимает запрос на выборку документа, который надо обновить
2. ```objNew```: представляет документ с новой информацией, который заместит старый при обновлении

3. ```options```: определяет дополнительные параметры при обновлении документов. Может принимать два аргумента: ```upsert``` и ```multi```.

Если параметр ```upsert``` имеет значение true, что mongodb будет обновлять документ, если он найден, и создавать новый, если такого документа нет. Если же он имеет значение false, то mongodb не будет создавать новый документ, если запрос на выборку не найдет ни одного документа.

Параметр ```multi``` указывает, должен ли обновляться первый элемент в выборке (используется по умолчанию, если данный параметр не указан) или же должны обновляться все документы в выборке.
```js
db.cats.update({name : "Bars"}, {name: "Tom", age : 5}, {upsert: true})
```
оператор ```$set``` - если документ не содержит обновляемое поле, то оно создается
```js
db.cats.update({name : "Tom"}, {$set: {characteristics: ['гадит в лоток', 'не дает себя гладить', 'серый']}})
```
Указав значение ```multi:true```, мы можем обновить все документы выборки
```js
{multi:true}
```

Для удаления отдельного ключа используется оператор ```$unset```:
```js
db.cats.update({name : "Tom"}, {$unset: {age: 1}})
```

### Метод updateOne и updateMany
Метод ```updateOne``` похож на метод ```update``` за тем исключением, что он обновляет только один документ.
Если необходимо обновить все документы, соответствующие некоторому критерию, то применяется метод ```updateMany()```:

### Массивы

#### Оператор ```$push```
```js
db.cats.updateOne({name : "Tom"}, {$push: {characteristics: "вонюч"}})
db.cats.updateOne({name : "Tom"}, {$push: {characteristics: {$each: ["храпит", "злой"]}}})
```

#### Оператор ```$addToSet```
Оператор ```$addToSet``` подобно оператору ```$push``` добавляет объекты в массив. Отличие состоит в том, что ```$addToSet``` добавляет данные, если их еще нет в массиве:
```js
db.cats.update({name : "Lama"}, {$addToSet: {characteristics: "безумен"}})
```
#### Оператор ```$pop``` 
Позволяет удалять элемент из массива:
```js
db.cats.update({name : "Tom"}, {$pop: {characteristics: 1}})
```
> 1 конец массива
> -1 начало массива

#### Оператор ```$pull ```
Удаляет по значению
```js
db.cats.update({name : "Tom"}, {$pull: {characteristics: "серый"}})
```
#### Оператор ```$pullAll```
А если мы хотим удалить не одно значение, а сразу несколько, тогда мы можем:
```js
db.cats.update({name : "Tom"}, {$pullAll: {characteristics: ["не дает себя гладить", "вонюч", "храпит"]}})
```

### Удаление

Для удаления документов в MongoDB предусмотрен метод ```remove```:
```js
db.cats.remove({name : "Tom"})
db.cats.remove({name : "Tom"}, true) - once
db.cats.remove({name : "Tom"}, false) - default multi 
```


## Homework 2

### Задание:

## Домашнее задание

1. Создать базу данных для своего проекта (бесплатную)

- https://docs.mlab.com/
- либо же здесь https://www.mongodb.com/cloud/atlas

2. Подключить базу данных к проекту
   Как в примере - 04-models-controllers - установить версию пакета "mongodb": "^2.2.33".
   Логику подключения к Базе данных вынести в отдельный файл.

3. Перенести все запросы что сделали до этого на Express. Всю логику разлелить и
   вынести в отдельные файлы (система MVC)
   По примеру - 04-models-controllers

Необходимо реализовать селедующие методы:

- POST `/costs` сохранение одного товара/затраты в базу данных

```json
{
  "name": "Пицца Пепперони с томатами",
  "description": "",
  "price": "100",
  "currency": "UAN",
  "created": "21-07-2019",
  "modified": "23-07-2019",
  "categories": "food"
}
```

- GET `/costs` в ответе должны прийти все товары из базы данных
- GET `/costs/:id` в получаем затрату из базы, найденную в базе по "\_id"
- PATCH `/costs/:id` обновление любого выбранного на ваше усмотрения поля у объекта затраты
Обновление отдельного поля - Для этого применяется оператор $set. Если документ не содержит обновляемое поле, то оно создается.
db.get().collection('costs').updateOne({ _id: ObjectID(id) }, {$set: { price: 150}})
- DELETE `/costs/:id` удаление объекта затраты



#### Требования

- Приложение должно лежать в отдельном вашем репозитории с названием `wallet-server-goit`
- Все задание нужно делать в ветке `homework-2`
- После того как закончите задание нужно сделать pull request в ветку `master`

# Lesson 2. Node js основы

- http, коды состояний http, https, cors
- Архитектура REST. RESTful API
- Semver
- Объект global, глобальные переменные
- Работа с каталогами
- Работа с файлами

## Что такое HTTP?

HTTP - это протокол передачи гипертекста. HTTP функционирует как протокол запроса-ответа в модели клиент-сервер.

## Коды состояния HTTP

Прежде чем погрузиться в общение с другими API-интерфейсами, давайте рассмотрим коды состояния HTTP, с которыми мы можем столкнуться во время работы нашего приложения. Они описывают результаты наших запросов и очень важны для обработки ошибок.

- 1xx — Информационный
- 2xx — Успех: Эти коды состояния говорят о том, что наш запрос был получен и обработан правильно. Наиболее распространённые коды успеха - `200 OK`, `201 Created` и `204 No Content`.
- 3xx — Редирект: Эта группа кодов показывает, что клиент должен будет выполнить дополнительные действия для завершения запроса. Наиболее распространёнными кодами перенаправления являются `301 Moved Permanently`, `304 Not Modified`.
- 4xx — Ошибка клиента. Этот класс кодов состояния используется, когда запрос, отправленный клиентом, содержит какую-то ошибку. Ответ сервера обычно содержит объяснение ошибки. Наиболее распространёнными кодами ошибок клиента являются `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `409 Conflict`.
- 5xx - Ошибка сервера: эти коды отправляются, когда сервер не смог выполнить корректный запрос из-за какой-то ошибки. Причиной может быть ошибка в коде или некоторая временная или постоянная неисправность. Наиболее распространённые коды ошибок сервера: `500 Internal Server Error`, `503 Service Unavailable`.

Если вы хотите узнать больше о кодах состояния HTTP, вы можете найти подробное объяснение [здесь](http://www.restapitutorial.com/httpstatuscodes.html).

## HTTPS

HTTPS — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS.

HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения

В протоколе HTTPS используется асимметричная схема шифрования за счет использования гибридной системы TLS (усовершенствованный SSL). Во всей сложной системе в роли замка выступает как раз он.

Чтобы подготовить веб-сервер для обработки https-соединений, разработчик должен получить и установить в систему сертификат открытого ключа для этого веб-сервера.

В TLS используется как асимметричная схема шифрования (в которой учавствуют 2 ключа), так и симметричная (для обмена данными, зашифрованными общим ключом). Сертификат публичного ключа (**public key**) посылается клиенту при установлении соединения; Приватный ключ (**private key**) используется для расшифровки сообщений от клиента.

[Что такое https, как получить бесплатный сертификат для статического сайта](https://www.youtube.com/watch?v=-G256iibFYg)
[Установка сертификата в node.js](https://www.youtube.com/watch?v=r92gqYHJc5c)

## CORS (Cross-Origin Resource Sharing)

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Пример cross-origin запроса: HTML страница, обслуживаемая сервером с `http://domain-a.com`, запрашивает <img> src по адресу `http://domain-b.com/image.jpg`. Здесь у нас разные домены и в разрешении связей между ними учавствует CORS.

Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, `XMLHttpRequest` и `Fetch API` следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.

[Больше о СORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)

[Настройка CORS на node js](https://www.youtube.com/watch?v=bo0Asv8L9Vg)

## Архитектура REST. RESTful API

REST — REpresentational State Transfer. Это передача/изменения состояния через представления. REST — это архитектурный стиль, некоторое множество ограничений, для построения распределенных приложений.

Архитектура REST описывается следующими ограничениями.

- [Единый интерфейс (Uniform Interface)](http://www.restapitutorial.ru/lessons/whatisrest.html#uniform-interface)
- [Отсутствие состояний (Stateless)](http://www.restapitutorial.ru/lessons/whatisrest.html#stateless)
- [Кеширование ответа (Cacheable)](http://www.restapitutorial.ru/lessons/whatisrest.html#cacheable)
- [Клиент-сервер (Client-Server)](http://www.restapitutorial.ru/lessons/whatisrest.html#client-server)
- [Многоуровневая система (Layered System)](http://www.restapitutorial.ru/lessons/whatisrest.html#layered-system)

Чем больше ограничений вы выполните, тем более "full" получится приложение. В теории при выполнении всех требований вы получайте **RESTful** приложение, если соблюдать только часть из них это **REST-like**.

Ключевое понятие в REST — это ресурс. Ресурс имеет состояние, и мы можем его получать или изменять при помощи представлений. Наше приложение отвечает за некоторое множество таких ресурсов. Кстати, совокупное состояние ресурсов — это и есть состояние приложения.

Примеры ресурсов:

- Пользователи системы
- Курсы, в которых зарегистрирован студент
- История сообщений пользователя
- Пользователь
- Товар магазина
- Товары магазина
- Категория товаров магазина
- Категории товаров магазина

Чтобы создать нового покупателя в системе мы используем:

`POST http://www.example.com/customer`

Чтобы создать новый товар мы используем:

`POST http://www.example.com/product`

Для чтения, обновления, удаления продукта с id `66432`.

`GET|PUT|DELETE http://www.example.com/products/66432`

Чтобы получить информацию о товаре с id `12345` мы используем :

`GET http://www.example.com/product/12345`

Тот же URI мы используем для PUT и DELETE, чтобы обновлять и удалять, соответственно.

Ниже предложен URI для получения всех продуктов:

`GET http://www.example.com/products`

Продуктов определенной категории:

`GET http://www.example.com/auto/products`

Каждый ресурс сервиса должен иметь хотя бы один URI, идентифицирующий его. И лучше всего, когда этот URI имеет смысл и адекватно описывает этот ресурс. URI должны иметь предсказуемую структуру.

Под представлением можно понимать JSON/HTML/XML/текст в определенном формате или что угодно, что позволяет нам понимать состояние ресурса или его модифицировать.

### Статьи

- [Именование ресурсов](http://www.restapitutorial.ru/lessons/restfulresourcenaming.html)
- [Понимание REST](https://dou.ua/lenta/articles/rest-conception/)

## SEMVER

Когда мы устанавливаем какой-то пакет, например, express, то в package.json добавляется последняя версия пакета, состоящая из трех цифр. Эти цифры означают Major, Minor, Patch и используют как спецификацию semver.

Что это значит? Когда я делаю пакет и еще не опубликовал его, то первая цифра идет 0. Это значит, что какие бы номера версий не шли дальше, я могу в любом момент менять любой функционал пакета. Потому что пакет, начинающийся с 0 - нестабильный пакет.

Когда мы опубликовали пакет, то каждый номер версии начинает иметь смысл. Последняя цифра - это PATCH. То есть внесение незначительных изменений в пакет, например bugfix.

Средняя цифра - это минорная версия. Она должна обновляться при изменениях, которые добавляют новый функционал, но не ломают то, что уже работает. Таким образом любой человек может обновится с 1.2.0 на 1.3.0 и все должно по прежнему работать.

Первая же цифра - это мажорная версия. Если внеслись хоть какие-то изменения, которые сломали текущий код, то должна релизится новая мажорная версия. Это может быть как изменение API, так и изменение порядка аргументов. Поэтому нужно делать версию 2.0.0.

Собственно вся система версий и пакетов подчиняется спецификации semver.

Мы можем указать, что пакет должен быть больше версии 1.2.7

`>= 1.2.7`

Тогда, при установке пакетов версия будет искаться только среди версий, которые больше 1.2.7.

Также можно указывать range.

`>=1.2.7 <1.3.0`

Также есть специальные пре релизные теги.

`1.2.3-alpha.3`
`1.2.3-beta.0`

Также часто встречаются тильда и каретка.

Когда у нас стоит тильда

`~1.2.3`
Это значит, что версия может меняться только от 1.2.3 до 1.3.0, то есть могут применятся только патчи, а минорная версия обновлятся не может.

Если же у нас стоит каретка

`^1.2.3`
То можно обновлять и минорную версию и накатывать патчи. То есть от 1.2.3 до 2.0.0.

[Видео с обьяснением](https://monsterlessons.com/project/lessons/razbiraemsya-s-versiyami-paketov-v-node)

## Объект global, глобальные переменные

Node.js предоставляет специальный объект `global`, который предоставляет доступ к глобальным, то есть доступным из каждого модуля приложения, переменным и функциям.

Примерным аналогом данного объекта в javascript для браузера является объект `window`. Все доступные глобальные объекты можно посмотреть в [документации](https://nodejs.org/api/globals.html).

Примеры глобальных переменных:

- `__filename` указывает имя файла который в настоящее время выполняется. Абсолютный путь к месту где находится файл.
- `__dirname` указывает адрес каталога где лежит файл что сейчас выполняется. Абсолютный путь к месту где находится каталог.
- `setInterval, setTimeout`
- `process`

[Документация на русском](http://www.w3big.com/ru/nodejs/nodejs-global-object.html)

Рекомендуется избегать определения и использования глобальных переменных, и преимущественно ориентироваться на создание переменных, инкапсулированных в рамках отдельных модулей.

[Статья с примером](https://metanit.com/web/nodejs/2.3.php)

## Работа с каталогами

В Node JS есть модуль отвечающий за работу с директориями и файлами. Он называется fs (file system).

#### Проверить существует ли директория

`fs.existsSync(path)`

ВАЖНО! `fs.exists(path,cb)` deprecated, по этому нужно использовать только его синхронный аналог.

#### Создание директории

`fs.mkdir(path[, mode], callback);`

- `path` — это имя директории, включая путь к ней.
- `mode` – это права доступа к директории. По умолчанию — 0777.
- `callback` — это функция обратного вызова. Никакие аргументы кроме возможных исключений не передаются функции обратного вызова завершения.

Пример

```
var fs = require("fs");

console.log("Going to create directory /tmp/test");
fs.mkdir('/tmp/test',function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Directory created successfully!");
});
```

#### Чтение директории

`fs.readdir(path, callback);`

Пример

```
var fs = require("fs");

console.log("Going to read directory /tmp");
fs.readdir("/tmp/",function(err, files){
   if (err) {
      return console.error(err);
   }
   files.forEach( function (file){
      console.log( file );
   });
});
```

#### Удаление директории

`fs.rmdir(path, callback)`

Пример

```
var fs = require("fs");

console.log("Going to delete directory /tmp/test");
fs.rmdir("/tmp/test",function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Going to read directory /tmp");

   fs.readdir("/tmp/",function(err, files){
      if (err) {
         return console.error(err);
      }
      files.forEach( function (file){
         console.log( file );
      });
   });
});
```

[Видое о работе с директориями](https://www.youtube.com/watch?v=GlsyhBFfrgg)

## Работа с файлами

Пример чтения файла

```
var fs = require("fs");

// Asynchronous read
fs.readFile('input.txt', function (err, data) {
   if (err) {
      return console.error(err);
   }
   console.log("Asynchronous read: " + data.toString());
});

// Synchronous read
var data = fs.readFileSync('input.txt');
console.log("Synchronous read: " + data.toString());

console.log("Program Ended");
```

### Флаги для операций чтения/записи :

`r`— Открыть файл для чтения. Если файл не существует, добавляется исключение.

`г+` — Открыть файл для чтения и записи. Если файл не существует, добавляется исключение.

`rs`— Открыть файл для чтения в синхронном режиме.

`rs+` — Открыть файл для чтения и записи, запросив у ОС открыть его в синхронном режиме.

`w`— Открыть файл для записи. Файл создается (если он не существует) или усекается (если он существует).

`wx`— Работает так же как «w», но не выполняется, если путь существует.

`w+` — Открыть файл для чтения и записи. Если файл не существует, он создается, если файл существует, он усекается.

`wx+` — Работает так же как «w+», но не выполняется, если путь существует.

`a`— Открыть файл для дополнения. Если файл не существует, он создается.

`ax`— Работает как «а», но не выполняется, если путь существует.

`a+` — Открыть файл для чтения и расширения. Если файл не существует, он создается.

`ах`+ — Работает так же как «a+», но не выполняется, если путь существует.

#### Пример

```
// fs_write.js

const fs = require('fs');

// Путь к файлу который мы хотим изменить
let path = 'ghetto_gospel.txt';
let buffer = new Buffer('Those who wish to follow me\nI welcome with my hands\nAnd the red sun sinks at last');

// открыть файл в режиме записи, добавить коллбек в котором сделать запись в файл
fs.open(path, 'w', function(err, fd) {
    if (err) {
        throw 'could not open file: ' + err;
    }

    // записать контент в буфер с позиции 0 до конца
    fs.write(fd, buffer, 0, buffer.length, null, function(err) {
        if (err) throw 'error writing file: ' + err;

        // Завершить изменение файла
        fs.close(fd, function() {
            console.log('wrote the file successfully');
        });
    });
```

Для перезаписи файла можно использовать более простой метод `fs.writeFile()`

[Статья "Как писать данные в файлы"](https://stackabuse.com/writing-to-files-in-node-js/)

```
var fs = require('fs');

fs.writeFile('mynewfile3.txt', 'This is my text', function (err) {
  if (err) throw err;
  console.log('Replaced!');
});
```

#### Запись файла

`fs.writeFile(filename, data[, options], callback)`

Этот метод перезаписывает файл, если файл уже существует. Если вы хотите дописать что-то в существующий файл, вы должны использовать другой доступный метод.

### Переименовать файл

`fs.rename(new_file_path, old_file_path, callback_function)`

#### Удаление файла

`fs.unlink(path, callback)`

```
var fs = require("fs");

console.log("Going to delete an existing file");
fs.unlink('input.txt', function(err) {
   if (err) {
      return console.error(err);
   }
   console.log("File deleted successfully!");
});
```

#### Получение информации о файлах

`fs.stat(path, callback)`

Чаще всего используемы только эти 2 метода:

`stats.isFile()` — Возвращает true, если тип файла — простой файл.

`stats.isDirectory()` — Возвращает true, если тип файла — каталог.

[Статья о работе с файлами и директориями](https://webformyself.com/node-js-fs-fajlovaya-sistema/)

## Express

> Быстрый, гибкий, минималистичный веб-фреймворк для Node.js — [http://expressjs.com/](http://expressjs.com/)

Добавление Express в ваш проект - это просто установка через NPM:

```javascript
$ npm i express
```

После того, как вы установили Express, давайте посмотрим, как создать приложение аналогичное тому, что мы написали ранее, в уроке 1, с помощью модуля http:

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (request, response) => {
  response.send("Hello from Express!");
});

app.listen(port, err => {
  if (err) {
    return console.log("something bad happened", err);
  }

  console.log(`server is listening on ${port}`);
});
```

Самое большое различие, которое вы можете здесь заметить, заключается в том, что Express по умолчанию даёт вам роутер. Вам не нужно вручную разбирать URL, чтобы решить, что делать, вместо этого вы определяете маршрутизацию приложения с помощью `app.get`, `app.post`, `app.put` и так далее, а они уже транслируются в соответствующие HTTP-запросы.

Одна из самых мощных концепций, которую реализует Express — это паттерн Middleware.

## Middleware — промежуточный обработчик

Вы можете думать о промежуточных обработчиках как о конвейерах Unix, но для HTTP-запросов.

![](middlewares.png)

На диаграмме вы можете увидеть, как запрос идёт через условное Express-приложение. Он проходит через три промежуточных обработчика. Каждый обработчик может изменить этот запрос, а затем, основываясь на вашей бизнес-логике, третий middleware отправит ответ, либо запрос попадёт в обработчик соответствующего роута.

На практике вы можете сделать это следующим образом:

```javascript
const express = require("express");
const app = express();

app.use((request, response, next) => {
  console.log(request.headers);
  next();
});

app.use((request, response, next) => {
  request.chance = Math.random();
  next();
});

app.get("/", (request, response) => {
  response.json({
    chance: request.chance
  });
});

app.listen(3000);
```

Что следует здесь отметить:

- `app.use`: это то, как вы можете описать middleware. Этот метод принимает функцию с тремя параметрами, первый из которых является запросом, второй — ответом, а третий — коллбеком `next`. Вызов `next` сигнализирует Express о том, что он может переходить к следующему промежуточному обработчику.
- Первый промежуточный обработчик только логирует заголовки и мгновенно вызывает следующий.
- Второй добавляет дополнительное свойство к запросу - **это одна из самых мощных функций шаблона middleware**. Ваши промежуточные обработчики могут добавлять дополнительные данные к объекту запроса, который могут считывать/изменять middleware, расположенные ниже.

Написание кода промежуточных обработчиков для использования в приложениях Express — [https://expressjs.com/ru/guide/writing-middleware.html](https://expressjs.com/ru/guide/writing-middleware.html)

## Обработка ошибок

Как и во всех фреймворках, правильная обработка ошибок имеет решающее значение. В Express вы должны создать специальный промежуточный обработчик - middleware с четырьмя входными параметрами:

```javascript
const express = require("express");
const app = express();

app.get("/", (request, response) => {
  throw new Error("oops");
});

app.use((err, request, response, next) => {
  // логирование ошибки, пока просто console.log
  console.log(err);
  response.status(500).send("Something broke!");
});

app.listen(3000);
```

Что следует здесь отметить:

- Обработчик ошибок должен быть последней функцией, добавленной с помощью `app.use`.
- Обработчик ошибок принимает коллбек `next`. Он может использоваться для объединения нескольких обработчиков ошибок.

## Рендеринг HTML

Ранее мы рассмотрели, как отправлять JSON-ответы. Пришло время узнать, как отрендерить HTML простым способом. Для этого мы собираемся использовать пакет [handlebars](http://handlebarsjs.com/) с обёрткой [express-handlebars](https://www.npmjs.com/package/express-handlebars).

Сначала создадим следующую структуру каталогов:

```
├── index.js
└── index.html
```

После этого заполните `index.js` следующим кодом:

```javascript
// index.js
const path = require("path");
const express = require("express");
const exphbs = require("express-handlebars");

const app = express();
app.engine(
  ".hbs",
  exphbs({
    defaultLayout: "main",
    extname: ".hbs",
    layoutsDir: path.join(__dirname, "views/layouts")
  })
);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

app.listen(3000);
```

Приведенный выше код инициализирует движок handlebars и устанавливает каталог шаблонов в `views/layouts`. Это каталог, в котором будут храниться ваши шаблоны.

После того, как вы сделали эту настройку, вы можете поместить свой начальный `html` в `main.hbs`. Чтобы всё было проще, давайте сразу перейдём к этому:

```html
<html>
  <head>
    <title>Express handlebars</title>
  </head>
  <body>
    {{{body}}}
  </body>
</html>
```

Вы можете заметить метку `{{{body}}}` — здесь будет размещен ваш контент. Давайте создадим `home.hbs`!

```html
<h2>Hello {{name}}</h2>
```

Последнее, что мы должны сделать, чтобы заставить всё это работать, - добавить обработчик маршрута в наше приложение Express:

```javascript
app.get("/", (request, response) => {
  response.render("home", {
    name: "John"
  });
});
```

Метод `render` принимает два параметра:

- Первый — это имя шаблона.
- Второй — данные, необходимые для рендеринга.

Как только вы сделаете запрос по этому адресу, вы получите что-то вроде этого:

```html
<html>
  <head>
    <title>Express handlebars</title>
  </head>
  <body>
    <h2>Hello John</h2>
  </body>
</html>
```

Это всего лишь верхушка айсберга. Чтобы узнать, как добавить больше шаблонов (и даже частичных), обратитесь к официальной документации [express-handlebars](https://www.npmjs.com/package/express-handlebars).

## Отладка Express

В некоторых случаях вам может потребоваться выяснить, что происходит с Express, когда приложение работает. Для этого вы можете передать следующую переменную окружения в Express: `DEBUG=express*`.

Вы должны запустить свой Node.js HTTP-сервер, используя:

```
$ DEBUG=express* node index.js
```

## Postman

Что бы понять как работает Postman можно воспользоватся тренировочным сервисом.
Запускаем Postman

Переходим по ссылке https://api.chucknorris.io/

Тут мы можем из готового API получить забавные ответы.

Для того что бы воспользоваться расширенными возможностями Postman в параметры мы можем задать например - category - "movie"

---

## Homework 1

Мы будем делать онлайн сервис по ведению учета финансов. На бекенд курсе - делаем сервер.

В работе над заданиями проявляйте креативность, принимайте решение в мелочах как вам больше нравится. Подумайте над тем как по-вашему мнению должено работать такое приложение. Это будет полностью ваш проект.

### Задание:

- Сделать основу бекенд приложения (по примеру в папочке express-test_03)
- Создать `json` с затратами

  - Скачать этот `json` - costs-mock.json
  - Расширить по примеру еще 5 тратами
  - Сохранить `json` под названием `all-costs.json` по адресу `src/db/costs`

- Сделать роутинг

- В роутинге должны быть следующие пути:

  - GET `/costs` в ответе должны прийти все товары (из `all-costs.json`)

  - GET `/costs/:id` в ответе возможность получить данные какой-либо траты по `id На сервер приходит`GET localhost:3001/costs/12345`Ищете товар по`id`в`all-costs.json`
    Отправляете пользователю ответ в виде:

    ```json
    {
      "status": "success",
      "products": [
        {
          "id": 19112831,
          "name": "Пицца Пепперони с томатами",
          "description": "",
          "price": "100",
          "currency": "UAN",
          "created": "21-07-2019",
          "modified": "23-07-2019",
          "categories": ["food"]
        }
      ]
    }
    ```

````

 - GET `/costs/?category="food"` в ответе возможность получить данные нескольких продуктов по категориям

- На сервер приходит `GET localhost:3001/costs/?category="food"`
- Ищете товары по "categories" в `all-costs.json`
- Отправляете пользователю ответ в таком же виде как и в ответе выше.


Если в `all-costs.json` нет товаров что вы ищите, то ответ должен быть:

```json

{
 "status": "no products",
 "products": []
}
````

#### Требования

- Приложение должно лежать в отдельном вашем репозитории с названием `wallet-server-goit`
- Все задание нужно делать в ветке `homework-1`
- После того как закончите задание нужно сделать pull request в ветку `master`
